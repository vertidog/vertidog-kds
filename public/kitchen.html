<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>VertiDog KDS: Kitchen Display System</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      /* White/Light Ticket Theme */
      --bg: #050816;
      --card-bg: #fff; /* WHITE TICKETS */
      --new: #3b82f6;
      --progress: #f97316;
      --ready: #22c55e;
      --cancel: #ef4444;
      --text: #1f2937; /* Dark Text */
      --muted: #6b7280;
      --accent: #a855f7;
      --drag-hover-color: rgba(168, 85, 247, 0.22);
      --radius: 16px;
      
      /* Time Alert Colors (3 mins / 5 mins) */
      --time-alert: #f59e0b;   /* Amber (3 mins) */
      --time-critical: #ef4444; /* Red (5 mins) */
      --time-default: #1f2937;  /* Dark text color for timer */

      /* User configurable: Controls how many rows the KDS uses */
      --grid-rows: 1; 
      /* Fixed width for a card when in a single row or narrow grid */
      --card-width: 400px;
    }

    /* -----------------------------
      GENERAL STYLES
    --------------------------------*/
    body {
      background-color: var(--bg);
      color: var(--text);
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    /* -----------------------------
      KDS GRID LAYOUT
    --------------------------------*/
    .kds-container {
      display: grid;
      grid-template-columns: 1fr;
      height: 100vh;
      overflow: hidden;
    }

    .kds-tabs {
        display: flex;
        justify-content: flex-start;
        align-items: center;
        gap: 16px;
        padding: 10px 20px;
        background-color: #1f2937; /* Dark header bar */
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }
    
    .kds-tab {
        background: none;
        border: none;
        color: var(--muted);
        font-size: 1.2rem;
        font-weight: bold;
        padding: 8px 15px;
        cursor: pointer;
        border-radius: 8px;
        transition: color 0.2s, background-color 0.2s;
    }

    .tab-count {
        margin-left: 8px;
        background: rgba(255, 255, 255, 0.15);
        color: var(--card-bg);
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.9rem;
    }
    
    .kds-tab.active {
        color: var(--card-bg); /* White text for active tab */
        background-color: var(--new); /* Blue highlight for active tab */
    }

    .kds-tab-content {
      flex-grow: 1;
      overflow: hidden;
      padding: 10px;
    }

    .bubble-grid {
      display: grid;
      gap: 10px;
      /* Default grid setup for active tickets */
      grid-template-columns: repeat(auto-fill, minmax(var(--card-width), 1fr));
      align-items: start;
      align-content: start;
      padding: 5px;
      height: calc(100vh - 70px); /* Adjust height based on header height */
      overflow-y: auto;
    }

    .empty-state {
        color: var(--card-bg);
        text-align: center;
        padding: 20px;
        background: rgba(255, 255, 255, 0.08);
        border-radius: var(--radius);
        border: 1px dashed rgba(255, 255, 255, 0.2);
    }

    /* -----------------------------
      TICKET (BUBBLE) STYLES
    --------------------------------*/
    .order-bubble {
      background-color: var(--card-bg);
      border-radius: var(--radius);
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      display: flex;
      flex-direction: column;
      position: relative;
      overflow: hidden;
      color: var(--text);
      transition: all 0.2s ease-in-out;
    }

    /* Status Bar at the top of the ticket */
    .bubble-top-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 12px;
        color: white;
        font-weight: bold;
        text-transform: uppercase;
        font-size: 0.9rem;
    }
    .bubble-top-bar.new { background-color: var(--new); }
    .bubble-top-bar.in-progress { background-color: var(--progress); }
    .bubble-top-bar.ready { background-color: var(--ready); }
    .bubble-top-bar.cancelled { background-color: var(--cancel); }

    .bubble-body {
        padding: 12px;
        flex-grow: 1;
        display: flex;
        flex-direction: column;
    }
    
    .bubble-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 8px;
    }

    .bubble-number {
      font-size: 2.5rem;
      font-weight: 900;
      line-height: 1;
      color: var(--text);
    }
    .bubble-meta {
      font-size: 1rem;
      color: var(--muted);
      margin-top: 4px;
    }
    
    /* -----------------------------
      NEW ORDER DETAILS SECTION (Service Type & Note)
    --------------------------------*/
    .bubble-details {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        margin-top: 0.5rem;
        padding-top: 0.5rem;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
    }
    .service-type {
        font-size: 1.1rem;
        font-weight: 900;
        color: var(--accent);
        text-transform: uppercase;
    }
    .customer-note {
        font-size: 0.9rem;
        font-style: italic;
        color: var(--cancel);
        padding: 0.25rem;
        border: 1px dashed var(--cancel);
        border-radius: 4px;
    }
    
    /* Timer and Priority */
    .bubble-timer {
      font-size: 1.4rem;
      font-weight: 700;
      color: var(--time-default);
      transition: color 0.5s ease;
    }
    .prioritize-btn {
        background-color: var(--accent);
        color: white;
        border: none;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.8rem;
        cursor: pointer;
        transition: background-color 0.2s;
    }
    .prioritize-btn.is-prioritized {
        background-color: var(--new); /* Blue when prioritized */
    }

    /* -----------------------------
      ITEM LIST STYLES
    --------------------------------*/
    .bubble-items {
      margin-top: 10px;
      flex-grow: 1;
      padding-right: 5px; /* Space for scrollbar */
      overflow-y: auto;
    }

    .item-row {
      display: flex;
      align-items: baseline;
      gap: 10px;
      padding: 4px 0;
      border-bottom: 1px dashed rgba(0, 0, 0, 0.1);
      cursor: pointer;
      transition: background-color 0.1s;
    }
    .item-row.completed {
        opacity: 0.5;
        text-decoration: line-through;
        color: var(--muted);
    }

    .item-qty {
      font-size: 1.2rem;
      font-weight: 900;
      color: var(--text);
      flex-shrink: 0;
      width: 30px; /* fixed width for quantity */
    }

    .item-name {
      font-size: 1.2rem;
      font-weight: 600;
      flex-grow: 1;
    }

    .item-modifiers {
      list-style-type: none;
      padding: 0;
      margin: 0;
      margin-left: 30px; /* Indent below quantity */
    }

    .modifier-item {
      font-size: 1rem;
      color: var(--progress); /* Orange color for modifiers */
      margin-left: 10px;
    }
    .item-row.completed .modifier-item {
        color: var(--muted);
    }
    
    /* -----------------------------
      ACTION BUTTONS
    --------------------------------*/
    .bubble-actions {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(0, 0, 0, 0.1);
    }
    .complete-btn, .recall-btn {
      width: 100%;
      padding: 12px 20px;
      border: none;
      border-radius: 8px;
      font-size: 1.2rem;
      font-weight: bold;
      cursor: pointer;
      transition: opacity 0.2s;
    }
    .complete-btn {
      background-color: var(--ready);
      color: white;
    }
    .complete-btn:hover { opacity: 0.9; }

    .recall-btn {
      background-color: var(--new);
      color: white;
      margin-left: 10px;
      width: auto;
      font-size: 1rem;
      padding: 8px 12px;
    }

    .bubble-actions .recall-btn {
        display: block;
        width: 100%;
        margin: 0;
    }

    /* -----------------------------
      MEDIA QUERIES
    --------------------------------*/
    @media (max-width: 768px) {
        .kds-tabs {
            padding: 5px 10px;
            gap: 10px;
        }
        .kds-tab {
            font-size: 1rem;
            padding: 5px 10px;
        }
        .order-bubble {
            --card-width: 95vw;
        }
    }

  </style>
</head>
<body>
  <div class="kds-container">
    <div class="kds-tabs">
        <button class="kds-tab active" data-filter="active">Active Orders <span class="tab-count" id="tab-count-active">0</span></button>
        <button class="kds-tab" data-filter="ready">Completed Orders <span class="tab-count" id="tab-count-ready">0</span></button>
        <button class="kds-tab" data-filter="cancelled">Cancelled Orders <span class="tab-count" id="tab-count-cancelled">0</span></button>
    </div>
    <div class="kds-tab-content">
        <div id="active-bubble-grid" class="bubble-grid active"></div>
        <div id="ready-bubble-grid" class="bubble-grid" style="display: none;"></div>
        <div id="cancelled-bubble-grid" class="bubble-grid" style="display: none;"></div>
    </div>
  </div>

  <script>
    const API_URL = window.location.host;
    let ws = null;
    let store = {};
    let currentFilter = 'active';

    // Time constants in milliseconds
    const TIME_ALERT = 3 * 60 * 1000;    // 3 minutes
    const TIME_CRITICAL = 5 * 60 * 1000; // 5 minutes

    // --- Utility Functions ---

    /**
     * Safely escapes HTML special characters for display.
     */
    function escapeHtml(str) {
      if (typeof str !== 'string') return str;
      return str.replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
    }

    /**
     * Formats elapsed time since a given timestamp.
     */
    function formatTimeElapsed(timestamp) {
      const now = Date.now();
      const elapsed = now - timestamp;

      const totalSeconds = Math.floor(elapsed / 1000);
      const seconds = totalSeconds % 60;
      const totalMinutes = Math.floor(totalSeconds / 60);
      const minutes = totalMinutes % 60;
      const hours = Math.floor(totalMinutes / 60);

      const parts = [];
      if (hours > 0) {
        parts.push(hours.toString().padStart(2, '0'));
      }
      parts.push(minutes.toString().padStart(2, '0'));
      parts.push(seconds.toString().padStart(2, '0'));

      return parts.join(':');
    }

    // --- State Management ---

    function getBubbleContainer(status) {
        if (status === 'ready') return document.getElementById('ready-bubble-grid');
        if (status === 'cancelled') return document.getElementById('cancelled-bubble-grid');
        return document.getElementById('active-bubble-grid');
    }

    function getOrderFilter(order) {
        if (order.status === 'ready') return 'ready';
        if (order.status === 'cancelled') return 'cancelled';
        return 'active';
    }

    function getFilteredOrders(filter) {
        let orders = Object.values(store);
        
        // Sort by priority (prioritized first) and then by creation time (oldest first)
        orders.sort((a, b) => {
            if (a.isPrioritized && !b.isPrioritized) return -1;
            if (!a.isPrioritized && b.isPrioritized) return 1;
            return a.createdAt - b.createdAt;
        });

        if (filter === 'active') {
            return orders.filter(o => o.status === 'new' || o.status === 'in-progress');
        }
        return orders.filter(o => getOrderFilter(o) === filter);
    }

    function getTabCounts() {
        return Object.values(store).reduce((acc, order) => {
            acc[getOrderFilter(order)]++;
            return acc;
        }, { active: 0, ready: 0, cancelled: 0 });
    }

    function updateTabCounts() {
        const counts = getTabCounts();
        const activeEl = document.getElementById('tab-count-active');
        const readyEl = document.getElementById('tab-count-ready');
        const cancelledEl = document.getElementById('tab-count-cancelled');

        if (activeEl) activeEl.textContent = counts.active;
        if (readyEl) readyEl.textContent = counts.ready;
        if (cancelledEl) cancelledEl.textContent = counts.cancelled;
    }

    // --- Timer & Visuals ---

    function updateTimers() {
      const now = Date.now();
      const timerElements = document.querySelectorAll('.bubble-timer');
      
      const timeAlertColor = getComputedStyle(document.documentElement).getPropertyValue('--time-alert').trim();
      const timeCriticalColor = getComputedStyle(document.documentElement).getPropertyValue('--time-critical').trim();
      const timeDefaultColor = getComputedStyle(document.documentElement).getPropertyValue('--time-default').trim();


      timerElements.forEach(timerEl => {
        const orderId = timerEl.closest('.order-bubble').dataset.orderid;
        const order = store[orderId];
        
        if (!order) return;

        const elapsed = now - order.createdAt;
        timerEl.textContent = formatTimeElapsed(order.createdAt);
        
        // Set color based on elapsed time
        if (elapsed > TIME_CRITICAL) {
          timerEl.style.color = timeCriticalColor;
        } else if (elapsed > TIME_ALERT) {
          timerEl.style.color = timeAlertColor;
        } else {
          timerEl.style.color = timeDefaultColor;
        }
      });
    }

    // Set up the interval to update timers every second
    setInterval(updateTimers, 1000);

    // --- WebSocket Communication ---

    function sendWebSocketMessage(type, data = {}) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            const message = JSON.stringify({ type, ...data });
            ws.send(message);
        } else {
            console.warn("WebSocket is not open. Attempting to reconnect.");
            connect();
        }
    }

    window.markReady = function(orderNumber, orderId, event) {
        event.stopPropagation();
        if (confirm(`Mark order #${orderNumber} as COMPLETED?`)) {
            sendWebSocketMessage("ORDER_READY", { orderNumber, orderId });
        }
    }

    window.recallOrder = function(orderNumber, orderId, event) {
        event.stopPropagation();
        if (confirm(`Recall order #${orderNumber} back to Active?`)) {
            sendWebSocketMessage("ORDER_REACTIVATED", { orderNumber, orderId });
        }
    }

    window.cancelOrder = function(orderNumber, orderId, event) {
        event.stopPropagation();
        if (confirm(`Cancel order #${orderNumber}?`)) {
            sendWebSocketMessage("ORDER_CANCELLED", { orderNumber, orderId });
        }
    }

    window.togglePriority = function(orderNumber, orderId, event) {
        event.stopPropagation();
        const order = store[orderId];
        if (order) {
            const newPriority = !order.isPrioritized;
            // Optimistic update
            order.isPrioritized = newPriority; 
            sendWebSocketMessage("ORDER_PRIORITY_TOGGLE", { orderNumber, orderId, isPrioritized: newPriority });
            render(currentFilter);
        }
    }
    
    window.toggleItem = function(orderId, itemIndex) {
        const order = store[orderId];
        if (order && order.items[itemIndex]) {
            const newCompleted = !order.items[itemIndex].completed;
            order.items[itemIndex].completed = newCompleted; // Optimistic update
            
            // Check if all active items are now completed to prompt for order completion
            const allItemsCompleted = order.items.every(item => item.completed);

            if (allItemsCompleted && order.status !== 'ready' && order.status !== 'cancelled') {
                // If all items are completed, prompt to mark the entire order as ready
                if (confirm(`All items for order #${order.orderNumber} are done. Mark order as COMPLETED?`)) {
                    sendWebSocketMessage("ORDER_READY", { orderNumber: order.orderNumber, orderId: order.orderId });
                }
            } else {
                // Only toggle the item status if not completing the order
                sendWebSocketMessage("ORDER_ITEM_TOGGLE", {
                    orderNumber: order.orderNumber,
                    orderId: order.orderId,
                    itemIndex,
                    completed: newCompleted
                });
            }

            render(currentFilter); // Re-render to reflect the change visually
        }
    }

    // --- Rendering Functions ---

    function renderItemsHtml(orderId, items) {
        if (!Array.isArray(items) || items.length === 0) {
            return '<div style="color:var(--cancel);font-style:italic;">No items found.</div>';
        }

        let html = '';
        items.forEach((item, index) => {
            // Modifiers List
            const modifiersHtml = item.modifiers && item.modifiers.length > 0
                ? `<ul class="item-modifiers">
                    ${item.modifiers.map(m => `<li class="modifier-item">-- ${escapeHtml(m)}</li>`).join('')}
                   </ul>`
                : '';

            // Item Row
            html += `
                <div class="item-row ${item.completed ? 'completed' : ''}" 
                     data-item-index="${index}" 
                     onclick="window.toggleItem('${orderId}', ${index})">
                    <span class="item-qty">${escapeHtml(item.quantity)}x</span>
                    <span class="item-name">${escapeHtml(item.name)}</span>
                </div>
                ${modifiersHtml}
            `;
        });
        return html;
    }

    function render(filter) {
      currentFilter = filter;
      const ordersToRender = getFilteredOrders(filter);

      document.querySelectorAll('.kds-tab').forEach(tab => {
          tab.classList.toggle('active', tab.dataset.filter === filter);
      });

      const allContainers = document.querySelectorAll('.bubble-grid');
      allContainers.forEach(c => c.style.display = 'none');

      const bubbleContainer = getBubbleContainer(filter);
      if (bubbleContainer) {
          bubbleContainer.style.display = 'grid';
          bubbleContainer.innerHTML = ''; // Clear existing bubbles

          if (ordersToRender.length === 0) {
              const empty = document.createElement('div');
              empty.className = 'empty-state';
              const label = filter === 'ready' ? 'completed' : (filter === 'cancelled' ? 'cancelled' : 'active');
              empty.textContent = `No ${label} orders right now.`;
              bubbleContainer.appendChild(empty);
              updateTabCounts();
              return;
          }
      }

      ordersToRender.forEach(o => {
        const b = document.createElement('div');
        b.className = 'order-bubble';
        b.dataset.ordernumber = o.orderNumber;
        b.dataset.orderid = o.orderId;
        b.dataset.status = o.status;

        // Status-dependent content
        let statusText = o.status.toUpperCase().replace('-', ' ');
        const isActiveStatus = o.status === 'new' || o.status === 'in-progress';
        
        const priorityIcon = o.isPrioritized && isActiveStatus ? '‚≠ê' : '';

        // Priority Button
        const priorityBtn = isActiveStatus 
            ? `<button class="prioritize-btn ${o.isPrioritized ? 'is-prioritized' : ''}" onclick="window.togglePriority('${o.orderNumber}', '${o.orderId}', event)">${o.isPrioritized ? 'PRIORITIZED' : 'PRIORITIZE'}</button>` 
            : '';

        // Complete Button (only for active orders)
        const completeBtnHtml = isActiveStatus 
            ? `<button class="complete-btn" onclick="window.markReady('${o.orderNumber}', '${o.orderId}', event)">MARK COMPLETED</button>` 
            : '';

        // Recall Button (only for ready/cancelled orders)
        const recallButtonHtml = (o.status === 'ready' || o.status === 'cancelled')
            ? `<button class="recall-btn" onclick="window.recallOrder('${o.orderNumber}', '${o.orderId}', event)">RECALL</button>`
            : '';
        
        // Timer
        const timerHtml = isActiveStatus 
            ? `<span class="bubble-timer">${formatTimeElapsed(o.createdAt)}</span>` 
            : '';
        
        const itemCountText = `${o.itemCount} Item${o.itemCount === 1 ? '' : 's'}`;
        const itemsHtml = renderItemsHtml(o.orderId, o.items); 
        
        // --- NEW TEMPLATE INCLUDES serviceType and customerNote ---
        const noteHtml = o.customerNote 
            ? `<div class="customer-note">NOTE: ${escapeHtml(o.customerNote)}</div>` 
            : '';
            
        b.innerHTML = `
            <div class="bubble-top-bar ${o.status !== 'ready' ? o.status : ''}">
                <div>${statusText} ${priorityIcon} ${priorityBtn}</div>
                <div>${timerHtml}</div>
            </div>

            <div class="bubble-body">
                <div class="bubble-header">
                    <div>
                        <div class="bubble-number">${escapeHtml(o.orderNumber)}</div>
                        <div class="bubble-meta">${escapeHtml(itemCountText)}</div>
                    </div>
                    <div class="bubble-metas">
                        ${recallButtonHtml}
                    </div>
                </div>

                <div class="bubble-details">
                    <div class="service-type">${escapeHtml(o.serviceType)}</div>
                    ${noteHtml}
                </div>

                <div class="bubble-items">
                    ${itemsHtml}
                </div>
                
                <div class="bubble-actions">
                    ${completeBtnHtml}
                </div>
            </div>
        `;

        bubbleContainer.appendChild(b);
      });

      updateTabCounts();
      updateTimers();
    }

    // --- Tab Switching Logic ---
    document.querySelectorAll('.kds-tab').forEach(tab => {
        tab.addEventListener('click', (e) => {
            const filter = tab.dataset.filter;
            render(filter);
        });
    });

    // --- WebSocket Connection ---

    function handleNewOrder(data) {
        // Ensure new orders have the 'completed' field initialized
        if (data.items) {
            data.items = data.items.map(item => ({
                ...item,
                completed: item.completed ?? false
            }));
        }
        data.isPrioritized = data.isPrioritized ?? false;
        
        store[data.orderId] = data;
        render(currentFilter);
        updateTimers();
    }
    
    function handleSyncState(data) {
        store = {}; // Reset store
        data.orders.forEach(order => {
            // Ensure data structure is consistent on sync
            if (order.items) {
                order.items = order.items.map(item => ({
                    ...item,
                    completed: item.completed ?? false
                }));
            }
            order.isPrioritized = order.isPrioritized ?? false;
            store[order.orderId] = order;
        });
        render(currentFilter);
        updateTimers();
    }
    
    function handleOrderReadyConfirm(data) {
        const order = store[data.orderId] || Object.values(store).find(o => o.orderNumber === data.orderNumber);
        if (order) {
            order.status = data.status; // status is passed back as 'ready', 'in-progress', or 'cancelled'
            render(currentFilter);
        }
    }
    
    function handlePriorityToggle(data) {
        const order = store[data.orderId] || Object.values(store).find(o => o.orderNumber === data.orderNumber);
        if (order) {
            order.isPrioritized = data.isPrioritized;
            render(currentFilter);
        }
    }
    
    function handleItemToggle(data) {
        const order = store[data.orderId] || Object.values(store).find(o => o.orderNumber === data.orderNumber);
        if (order && order.items[data.itemIndex]) {
            order.items[data.itemIndex].completed = data.completed;
            render(currentFilter);
        }
    }


    function connect() {
      if (ws) { ws.close(); } // Close previous connection if exists

      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const url = `${protocol}//${API_URL}`;

      ws = new WebSocket(url);

      ws.onopen = () => {
        console.log('WebSocket connected. Requesting sync.');
        // Request initial state sync immediately after connecting
        sendWebSocketMessage("SYNC_REQUEST"); 
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          
          switch (data.type) {
            case 'SYNC_STATE':
                handleSyncState(data);
                break;
            case 'NEW_ORDER':
                handleNewOrder(data);
                break;
            case 'ORDER_READY_CONFIRM':
                handleOrderReadyConfirm(data);
                break;
            case 'ORDER_PRIORITY_TOGGLE':
                handlePriorityToggle(data);
                break;
            case 'ORDER_ITEM_TOGGLE':
                handleItemToggle(data);
                break;
            default:
              console.log('Unknown message type:', data.type);
          }
        } catch (e) {
          console.error('Error processing WebSocket message:', e);
        }
      };

      ws.onclose = (e) => {
        console.log('WebSocket closed. Reconnecting in 5 seconds...', e.reason);
        setTimeout(connect, 5000);
      };

      ws.onerror = (err) => {
        console.error('WebSocket error:', err);
        ws.close();
      };
    }

    // Start the connection process
    render(currentFilter);
    connect();
  </script>
</body>
</html>
