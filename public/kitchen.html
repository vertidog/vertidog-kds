<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>VertiDog KDS: Kitchen Display System</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #050816;
      --card-bg: #0b1020;
      --new: #3b82f6;
      --progress: #f97316;
      --ready: #22c55e;
      --cancel: #ef4444;
      --text: #e5e7eb;
      --muted: #94a3b8;
      --accent: #a855f7;
      --drag-hover-color: rgba(168, 85, 247, 0.22);
      --radius: 16px;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: radial-gradient(circle at top, #111827 0, #020617 50%, #000 100%);
      color: var(--text);
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* HEADER */
    header {
      padding: 0.9rem 1.15rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(15, 23, 42, 0.9);
      border-bottom: 1px solid rgba(148, 163, 184, 0.25);
      backdrop-filter: blur(10px);
      z-index: 10;
      gap: 1rem;
    }
    header .title {
      display: flex;
      flex-direction: column;
      gap: 0.15rem;
      min-width: 0;
    }
    header h1 {
      font-size: 1.2rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      margin: 0;
      color: var(--accent);
      line-height: 1.1;
      white-space: nowrap;
    }
    header .subtitle {
      font-size: 0.95rem; 
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    header .status-pill {
      padding: 0.35rem 0.8rem;
      border-radius: 999px;
      font-size: 0.9rem; 
      display: flex;
      align-items: center;
      gap: 0.5rem;
      background: rgba(34, 197, 94, 0.12);
      border: 1px solid rgba(34, 197, 94, 0.3);
      color: #bbf7d0;
      flex: 0 0 auto;
      white-space: nowrap;
    }
    header .dot {
      width: 0.55rem;
      height: 0.55rem;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 10px rgba(34, 197, 94, 0.9);
    }

    /* MAIN GRID (Drop Target) */
    main {
      flex: 1;
      padding: 0.9rem;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); 
      gap: 0.9rem;
      overflow-y: auto;
      min-height: 220px;
    }

    .empty-state {
      width: 100%;
      border: 1px dashed rgba(148, 163, 184, 0.35);
      border-radius: var(--radius);
      padding: 1.25rem;
      color: var(--muted);
      font-size: 1.15rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* DRAG STYLES */
    .drag-over-active {
      outline: 4px dashed var(--accent);
      background-color: var(--drag-hover-color);
      border-radius: var(--radius);
    }
    .drag-over-done {
      outline: 4px dashed var(--ready);
      background-color: rgba(34, 197, 94, 0.10);
      border-radius: var(--radius);
    }
    .dragging { opacity: 0.4; }

    /* CARD */
    .bubble {
      position: relative;
      width: 100%;
      min-height: 240px; 
      border-radius: var(--radius);
      cursor: grab;
      border: 2px solid transparent;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.45);
      transition: transform 0.1s ease-out, box-shadow 0.2s ease-out, border-color 0.2s ease-out, opacity 0.3s ease-out;
      user-select: none;
      touch-action: manipulation;
      padding: 1rem 1rem 0.95rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    .bubble:active { transform: scale(0.99); cursor: grabbing; }

    .bubble.selected {
      box-shadow: 0 0 0 4px rgba(168, 85, 247, 0.75), 0 12px 26px rgba(0, 0, 0, 0.65);
      border-color: var(--accent);
      transform: scale(1.01);
    }

    .bubble-status {
      position: absolute;
      top: 0.75rem;
      right: 0.75rem;
      font-size: 0.85rem; 
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      font-weight: 800;
      letter-spacing: 0.03em;
    }

    .bubble-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 1rem;
      padding-right: 6.8rem; 
    }

    .bubble-number {
      font-size: clamp(2.8rem, 4vw, 3.4rem); 
      font-weight: 900;
      line-height: 1;
    }

    .bubble-metas {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 0.2rem;
      text-align: right;
      min-width: 120px;
    }
    .bubble-timer {
      font-size: 1.35rem; 
      font-weight: 900;
      color: var(--text);
      line-height: 1.05;
    }
    .bubble-meta {
      font-size: 1.0rem; 
      color: var(--muted);
      font-weight: 650;
    }

    .bubble-items {
      flex: 1;
      border-top: 1px solid rgba(148, 163, 184, 0.18);
      padding-top: 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0.55rem;
      overflow: hidden;
    }

    .item-row {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 0.75rem;
    }
    .item-name {
      font-size: 1.15rem; 
      font-weight: 800;
      color: var(--text);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      flex: 1;
      min-width: 0;
    }
    .item-qty {
      font-size: 1.05rem;
      font-weight: 900;
      padding: 0.12rem 0.5rem;
      border-radius: 999px;
      border: 1px solid rgba(168, 85, 247, 0.35);
      background: rgba(168, 85, 247, 0.12);
      color: #f5f3ff;
      flex: 0 0 auto;
    }
    .item-mods {
      margin-top: 0.15rem;
      font-size: 0.98rem; 
      color: rgba(34, 197, 94, 0.92);
      font-style: italic;
      line-height: 1.2;
      padding-left: 0.85rem;
      border-left: 3px solid rgba(34, 197, 94, 0.45);
    }
    .items-more {
      margin-top: 0.35rem;
      font-size: 1.0rem;
      color: var(--muted);
      font-weight: 650;
    }

    /* Status Specific Styles */
    .bubble.new {
      background: var(--card-bg);
      border-color: var(--new);
      box-shadow: 0 0 12px rgba(59, 130, 246, 0.55), 0 6px 16px rgba(0,0,0,0.45);
    }
    .bubble.new .bubble-status { background: var(--new); color: #fff; }

    .bubble.in-progress {
      background: var(--card-bg);
      border-color: var(--progress);
      box-shadow: 0 0 12px rgba(249, 115, 22, 0.55), 0 6px 16px rgba(0,0,0,0.45);
    }
    .bubble.in-progress .bubble-status { background: var(--progress); color: #fff; }

    .bubble.ready {
      background: radial-gradient(circle at center, rgba(34, 197, 94, 0.22), var(--card-bg) 70%);
      border-color: var(--ready);
      box-shadow: 0 0 16px rgba(34, 197, 94, 0.75), 0 6px 16px rgba(0,0,0,0.45);
    }
    .bubble.ready .bubble-status { background: var(--ready); color: var(--card-bg); }

    /* COMPLETED SECTION (Drop Target) */
    #completed-section {
      padding: 0.75rem 0.9rem 0.95rem;
      border-top: 1px solid rgba(15, 23, 42, 0.9);
      background: #020617;
      min-height: 140px;
    }
    .completed-title {
      font-size: 0.95rem; 
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--muted);
      margin: 0 0 0.6rem;
    }
    .completed-grid {
      display: flex;
      gap: 0.6rem;
      overflow-x: auto;
      padding-bottom: 0.35rem;
    }

    .completed-grid .bubble {
      width: 220px;
      min-width: 220px;
      min-height: 110px;
      padding: 0.8rem 0.85rem;
      border-radius: 12px;
      cursor: grab;
    }
    .completed-grid .bubble-header { padding-right: 6.4rem; }
    .completed-grid .bubble-number { font-size: 1.75rem; }
    .completed-grid .bubble-timer { display: none; }
    .completed-grid .bubble-items { display: none; }
    .completed-grid .bubble-meta { font-size: 0.95rem; }

    .bubble.done {
      background: #111827;
      border-color: #334155;
      opacity: 0.9;
    }
    .bubble.done .bubble-status {
      background: rgba(148, 163, 184, 0.22);
      border: 1px solid rgba(148, 163, 184, 0.30);
      color: #e5e7eb;
    }

    .bubble.cancelled {
      background: #111827;
      border-color: var(--cancel);
      opacity: 0.95;
    }
    .bubble.cancelled .bubble-status { background: var(--cancel); color: #fff; }

    @media (max-width: 860px) {
      header .subtitle { display: none; } 
      main { grid-template-columns: 1fr; }
      .completed-grid .bubble { width: 200px; min-width: 200px; }
    }
  </style>
</head>

<body>
  <header>
    <div class="title">
      <h1>VERTIDOG KDS</h1>
      <span class="subtitle">Tap card to advance status. Drag cards between ACTIVE and COMPLETED.</span>
    </div>
    <div class="status-pill" id="connection-status">
      <span class="dot"></span>
      <span>Connected</span>
    </div>
  </header>

  <main id="bubble-container"
        ondragover="handleDragOver(event, 'active')"
        ondragleave="handleDragLeave(event, 'active')"
        ondrop="handleDrop(event, 'active')">
    <div class="empty-state" id="empty-state">
      <div>No active orders</div>
    </div>
  </main>

  <section id="completed-section"
           ondragover="handleDragOver(event, 'done')"
           ondragleave="handleDragLeave(event, 'done')"
           ondrop="handleDrop(event, 'done')">
    <div class="completed-title">Recently Completed / Cancelled</div>
    <div id="done-container" class="completed-grid"></div>
  </section>

  <audio id="ready-sound" preload="auto">
    <source src="/sounds/order-ready.mp3" type="audio/mpeg" />
  </audio>

  <script>
    const WS_URL =
      (location.protocol === "https:" ? "wss://" : "ws://") +
      location.host +
      "/ws";

    const bubbleContainer = document.getElementById("bubble-container");
    const emptyState = document.getElementById("empty-state");
    const connectionStatus = document.getElementById("connection-status");
    const readySound = document.getElementById("ready-sound");
    const doneContainer = document.getElementById("done-container");

    const orders = {};
    let socket;
    let selectedOrderNumber = null;

    // TTS + announcement queue
    let preferredVoice = null;
    let announcementQueue = [];
    let isAnnouncing = false;

    function escapeHtml(str) {
      return String(str ?? "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    function formatTimeElapsed(createdAt) {
      if (!createdAt) return "0s";
      const secondsElapsed = Math.floor(Math.max(0, Date.now() - createdAt) / 1000);
      const minutes = Math.floor(secondsElapsed / 60);
      const seconds = secondsElapsed % 60;
      if (minutes > 0) return `${minutes}m ${seconds.toString().padStart(2, "0")}s`;
      return `${seconds}s`;
    }

    /* -----------------------------
      TTS SETUP
    --------------------------------*/
    function loadVoices() {
      if (!("speechSynthesis" in window)) return;
      const voices = window.speechSynthesis.getVoices();
      preferredVoice =
        voices.find((v) => v.name && v.name.includes("Google US English")) ||
        voices.find((v) => v.lang && v.lang.startsWith("en")) ||
        null;
    }
    if ("speechSynthesis" in window) {
      window.speechSynthesis.onvoiceschanged = loadVoices;
      loadVoices();
    }

    function announceOrder(orderNumber) {
      if (!("speechSynthesis" in window)) return null;
      const msg = new SpeechSynthesisUtterance(`Order ${orderNumber} is ready for pick up`);
      msg.volume = 1.0;
      msg.rate = 0.98;
      msg.pitch = 1.02;
      if (preferredVoice) msg.voice = preferredVoice;
      window.speechSynthesis.speak(msg);
      return msg;
    }

    function queueAnnouncement(orderNumber) {
      announcementQueue.push(orderNumber);
      if (!isAnnouncing) playNextAnnouncement();
    }

    function playNextAnnouncement() {
      if (announcementQueue.length === 0) {
        isAnnouncing = false;
        return;
      }
      isAnnouncing = true;
      const orderNumber = announcementQueue.shift();

      const doTTS = () => {
        const utterance = announceOrder(orderNumber);
        if (utterance) utterance.onend = () => playNextAnnouncement();
        else playNextAnnouncement();
      };

      try {
        readySound.currentTime = 0;
        readySound.onended = () => { readySound.onended = null; doTTS(); };
        readySound.play().catch(() => { readySound.onended = null; doTTS(); });
      } catch (e) {
        doTTS();
      }
    }

    /* -----------------------------
      CONNECT TO WEBSOCKET
    --------------------------------*/
    function setConnectionState(connected) {
      const dot = connectionStatus.querySelector(".dot");
      const label = connectionStatus.querySelector("span:last-child");
      if (connected) {
        dot.style.background = "#22c55e";
        label.textContent = "Connected";
      } else {
        dot.style.background = "#f97316";
        label.textContent = "Reconnectingâ€¦";
      }
    }

    function connect() {
      setConnectionState(false);
      socket = new WebSocket(WS_URL);

      socket.onopen = () => {
        setConnectionState(true);
        sendMessage({ type: "SYNC_REQUEST" });
      };

      socket.onmessage = (event) => handleMessage(JSON.parse(event.data));

      socket.onclose = () => {
        setConnectionState(false);
        setTimeout(connect, 2000);
      };

      socket.onerror = () => {};
    }

    function sendMessage(msg) {
      if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify(msg));
      }
    }

    /* -----------------------------
      HANDLE INCOMING MESSAGES
    --------------------------------*/
    function handleMessage(msg) {
      switch (msg.type) {
        case "NEW_ORDER":
          addOrUpdate(msg.orderNumber, msg.status || "new", msg);
          break;

        case "SYNC_STATE":
          // FIXED: We now receive ALL orders from the server.
          // Clear and rebuild the state based on the authoritative server sync
          Object.keys(orders).forEach(key => delete orders[key]);
          (msg.orders || []).forEach((o) => addOrUpdate(o.orderNumber, o.status || "new", o));
          
          // Select an order if none is selected
          if (!selectedOrderNumber && (msg.orders || []).length > 0) {
            selectedOrderNumber = msg.orders.find(o => o.status !== 'done' && o.status !== 'cancelled')?.orderNumber;
          }
          break;

        case "ORDER_READY_CONFIRM":
          // Server acknowledges the status change and we trigger local Ready actions
          markReady(msg.orderNumber, { playSound: true, serverConfirmed: true });
          break;
      }
      render();
    }

    /* -----------------------------
      DRAG & DROP LOGIC
    --------------------------------*/
    function handleDragStart(event) {
      const orderNumber = event.currentTarget?.dataset?.order;
      event.dataTransfer.setData("text/plain", orderNumber);
      event.currentTarget.classList.add("dragging");
    }

    function handleDragEnd(event) {
      event.currentTarget.classList.remove("dragging");
    }

    function handleDragOver(event, targetType) {
      event.preventDefault();
      const targetElement = (targetType === "active") ? bubbleContainer : document.getElementById("completed-section");
      targetElement.classList.add(`drag-over-${targetType}`);
    }

    function handleDragLeave(event, targetType) {
      const targetElement = (targetType === "active") ? bubbleContainer : document.getElementById("completed-section");
      targetElement.classList.remove(`drag-over-${targetType}`);
    }

    window.handleDrop = function(event, targetType) {
      event.preventDefault();
      const orderNumber = event.dataTransfer.getData("text/plain");

      bubbleContainer.classList.remove("drag-over-active");
      document.getElementById("completed-section").classList.remove("drag-over-done");

      if (!orderNumber || !orders[orderNumber]) return;
      const orderId = orders[orderNumber].orderId;

      if (targetType === "active") {
        orders[orderNumber].status = "in-progress";
        sendMessage({ 
          type: "ORDER_REACTIVATED", 
          orderNumber: orderNumber,
          orderId: orderId,
        }); 
      } else if (targetType === "done") {
        orders[orderNumber].status = "done";
        sendMessage({ 
          type: "ORDER_SKIPPED_DONE", 
          orderNumber: orderNumber,
          orderId: orderId,
        });
      }

      selectedOrderNumber = orderNumber;
      render();
    }

    /* -----------------------------
      ORDER MANAGEMENT
    --------------------------------*/
    function addOrUpdate(orderNumber, status, data = {}) {
      const existing = orders[orderNumber] || {};
      orders[orderNumber] = {
        orderNumber,
        status,
        createdAt: data.createdAt || existing.createdAt || Date.now(),
        itemCount: data.itemCount ?? existing.itemCount ?? null,
        items: data.items || existing.items || [],
        orderId: data.orderId || existing.orderId,
      };

      if (status === "cancelled" && selectedOrderNumber === orderNumber) {
        selectedOrderNumber = null;
      }
    }

    function triggerReadyActions(orderNumber, options = {}) {
      const o = orders[orderNumber];
      if (!o) return;

      if (options.playSound) queueAnnouncement(orderNumber);

      setTimeout(() => {
        const oCheck = orders[orderNumber];
        // Only trigger 'done' if status is still 'ready' AND the server hasn't already sent a full 'done' update
        if (oCheck && oCheck.status === "ready") {
          oCheck.status = "done";
          
          sendMessage({ 
            type: "ORDER_SKIPPED_DONE", 
            orderNumber: oCheck.orderNumber,
            orderId: oCheck.orderId,
          });
          
          render();
        }
      }, 5000);
    }

    window.cycleStatus = function(orderNumber) {
      const o = orders[orderNumber];
      selectedOrderNumber = orderNumber;

      if (!o) return render();

      // If already completed/cancelled, just select it.
      if (o.status === "cancelled" || o.status === "done") {
        return render();
      }

      // Status cycling
      if (o.status === "new") {
        o.status = "in-progress";
      } else if (o.status === "in-progress") {
        o.status = "ready";
        sendMessage({ type: "ORDER_READY", orderNumber, orderId: o.orderId }); 
      } else if (o.status === "ready") {
        // Tapping ready order immediately marks it done (and persists it)
        o.status = "done";
        
        sendMessage({ 
            type: "ORDER_SKIPPED_DONE", 
            orderNumber: o.orderNumber,
            orderId: o.orderId,
        });
      }

      render();
    }

    function markReady(orderNumber, options = {}) {
      const o = orders[orderNumber];
      if (!o || o.status === "done" || o.status === "cancelled") return;
      
      // Ensure local status is "ready" (optional, as server may have sent it already)
      o.status = "ready";
      selectedOrderNumber = orderNumber;
      render();
      
      // Only trigger sound/timer if this action was confirmed by the server
      if (options.serverConfirmed) {
        triggerReadyActions(orderNumber, options);
      }
    }

    function updateTimers() {
      document.querySelectorAll(".bubble").forEach((bubbleEl) => {
        const orderNumber = bubbleEl.dataset.order;
        const order = orders[orderNumber];
        const timerEl = bubbleEl.querySelector(".bubble-timer");
        if (order && timerEl) timerEl.textContent = formatTimeElapsed(order.createdAt);
      });
    }
    setInterval(updateTimers, 1000);

    /* -----------------------------
      RENDERING
    --------------------------------*/
    function renderItemsHtml(items = [], maxItems = 5) {
      if (!Array.isArray(items) || items.length === 0) {
        return `<div class="items-more">No item details.</div>`;
      }

      const slice = items.slice(0, maxItems);
      const rows = slice.map((item) => {
        const name = escapeHtml(item?.name || "Item");
        const qty = Number(item?.quantity ?? 1);
        const mods = Array.isArray(item?.modifiers) ? item.modifiers.filter(Boolean) : [];
        const modsShown = mods.slice(0, 3).map(escapeHtml).join(", ");
        const modsMore = mods.length > 3 ? `, +${mods.length - 3} more` : "";

        return `
          <div>
            <div class="item-row">
              <div class="item-name">${name}</div>
              <div class="item-qty">x${Number.isFinite(qty) ? qty : 1}</div>
            </div>
            ${mods.length ? `<div class="item-mods">+ ${modsShown}${modsMore}</div>` : ``}
          </div>
        `;
      }).join("");

      const more = items.length > maxItems
        ? `<div class="items-more">+ ${items.length - maxItems} more item(s)</div>`
        : ``;

      return rows + more;
    }

    function render() {
      const list = Object.values(orders).sort((a, b) => a.createdAt - b.createdAt);

      const active = list.filter((o) => o.status !== "done" && o.status !== "cancelled");
      const done = list.filter((o) => o.status === "done" || o.status === "cancelled"); // Client filters here

      bubbleContainer.innerHTML = "";
      emptyState.style.display = 'flex'; 
      
      if (active.length === 0) {
        bubbleContainer.appendChild(emptyState);
      } else {
        emptyState.style.display = 'none'; 
        
        active.forEach((o) => {
          const isSelected = o.orderNumber === selectedOrderNumber;
          const b = document.createElement("div");
          b.className = `bubble ${o.status}${isSelected ? " selected" : ""}`;
          b.dataset.order = o.orderNumber;

          b.setAttribute("draggable", true);
          b.ondragstart = handleDragStart;
          b.ondragend = handleDragEnd;
          b.onclick = () => window.cycleStatus(o.orderNumber);

          const statusText =
            o.status === "new" ? "NEW" :
            o.status === "in-progress" ? "IN PROGRESS" : "READY";

          const itemCountText =
            o.itemCount ? `${o.itemCount} item${o.itemCount > 1 ? "s" : ""}` : "";

          b.innerHTML = `
            <div class="bubble-status">${statusText}</div>

            <div class="bubble-header">
              <div class="bubble-number">#${escapeHtml(o.orderNumber)}</div>
              <div class="bubble-metas">
                <div class="bubble-timer">${formatTimeElapsed(o.createdAt)}</div>
                <div class="bubble-meta">${escapeHtml(itemCountText)}</div>
              </div>
            </div>

            <div class="bubble-items">
              ${renderItemsHtml(o.items, 5)}
            </div>
          `;

          bubbleContainer.appendChild(b);
        });
      }

      doneContainer.innerHTML = "";
      done.forEach((o) => {
        const isSelected = o.orderNumber === selectedOrderNumber;
        const statusClass = o.status === "cancelled" ? "cancelled" : "done";

        const b = document.createElement("div");
        b.className = `bubble ${statusClass}${isSelected ? " selected" : ""}`;
        b.dataset.order = o.orderNumber;

        b.setAttribute("draggable", true);
        b.ondragstart = handleDragStart;
        b.ondragend = handleDragEnd;

        b.onclick = () => { selectedOrderNumber = o.orderNumber; render(); };

        const itemCountText =
          o.itemCount ? `${o.itemCount} item${o.itemCount > 1 ? "s" : ""}` : "";

        b.innerHTML = `
          <div class="bubble-status">${statusClass.toUpperCase()}</div>

          <div class="bubble-header">
            <div class="bubble-number">#${escapeHtml(o.orderNumber)}</div>
            <div class="bubble-metas">
              <div class="bubble-meta">${escapeHtml(itemCountText)}</div>
            </div>
          </div>
        `;

        doneContainer.appendChild(b);
      });
    }

    connect();
  </script>
</body>
</html>
