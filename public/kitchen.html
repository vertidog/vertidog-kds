<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>VertiDog KDS: Kitchen Display System</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    /* ----------------------------------------------------
     * STYLES (Retained from user's custom layout)
     * ---------------------------------------------------- */
    :root {
      /* White/Light Ticket Theme */
      --bg: #050816;
      --card-bg: #fff; /* WHITE TICKETS */
      --new: #3b82f6; /* Blue */
      --progress: #f97316; /* Orange */
      --ready: #22c55e; /* Green */
      --cancel: #ef4444; /* Red */
      --text: #1f2937; /* Dark Text */
      --muted: #6b7280;
      --accent: #a855f7;
      --drag-hover-color: rgba(168, 85, 247, 0.22);
      --radius: 16px;
      
      /* Time Alert Colors (3 mins / 5 mins) */
      --time-alert: #f59e0b;   /* Amber (3 mins) */
      --time-critical: #ef4444; /* Red (5 mins) */
      --time-default: #1f2937;  /* Dark text color for timer */

      /* User configurable: Controls how many rows the KDS uses */
      --grid-rows: 1; 
      /* Fixed width for a card when in a single row or narrow grid */
      --card-width: 320px; 
    }

    body {
        margin: 0;
        padding: 0;
        background-color: var(--bg);
        color: var(--text);
        font-family: Arial, sans-serif;
        display: flex;
        flex-direction: column;
        height: 100vh;
    }

    /* KDS Grid Layout */
    #kds-grid {
        display: grid;
        grid-template-columns: repeat(var(--grid-rows), var(--card-width));
        grid-auto-rows: min-content;
        gap: 20px;
        padding: 20px;
        flex-grow: 1;
        overflow-y: auto;
        justify-content: start;
        align-content: start;
    }
    
    /* Global classes and utility styles */
    .bubble {
        background-color: var(--card-bg);
        border-radius: var(--radius);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        border: 2px solid transparent;
        transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
        cursor: grab;
        min-height: 200px; /* Base height for drag handle */
        opacity: 1;
    }
    
    /* Top Bar Status Coloring */
    .bubble-top-bar {
        padding: 8px 15px;
        color: white;
        font-weight: bold;
        display: flex;
        justify-content: space-between;
        align-items: center;
        text-transform: uppercase;
        font-size: 0.9em;
    }

    .bubble-top-bar.new { background-color: var(--new); }
    .bubble-top-bar.in-progress { background-color: var(--progress); }
    .bubble-top-bar.ready { background-color: var(--ready); color: var(--text); }
    .bubble-top-bar.cancelled { background-color: var(--cancel); }

    /* Bubble Content */
    .bubble-body {
        padding: 15px;
        flex-grow: 1;
        overflow: hidden;
        position: relative;
    }

    .bubble-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 10px;
    }
    
    .bubble-number {
        font-size: 2.5em;
        font-weight: 800;
        color: var(--text);
        line-height: 1;
    }
    
    .bubble-meta {
        font-size: 0.9em;
        color: var(--muted);
    }
    
    /* Items List */
    .bubble-items {
        padding-top: 10px;
        border-top: 1px solid #eee;
        max-height: 350px; /* Max height for items section before scroll */
    }

    .item {
        display: flex;
        justify-content: space-between;
        padding: 5px 0;
        font-size: 1.1em;
        color: var(--text);
        cursor: pointer;
        transition: background-color 0.1s;
    }
    
    .item:hover {
        background-color: #f7f7f7;
    }

    .item-left {
        display: flex;
        align-items: center;
        flex-grow: 1;
    }

    .item-name {
        margin-right: 10px;
        font-weight: 600;
    }
    
    .item-quantity {
        font-weight: bold;
        color: var(--accent);
    }

    /* Modifiers */
    .modifiers {
        font-size: 0.8em;
        color: var(--muted);
        margin-left: 25px;
        padding-bottom: 5px;
    }

    /* Item Completion States */
    .item.completed .item-name,
    .item.completed .modifiers {
        text-decoration: line-through;
        color: var(--muted);
    }

    .item-check {
        width: 20px;
        height: 20px;
        border: 2px solid var(--muted);
        border-radius: 4px;
        margin-right: 8px;
        display: flex;
        justify-content: center;
        align-items: center;
        color: white;
        font-size: 14px;
        transition: background-color 0.2s, border-color 0.2s;
    }

    .item.completed .item-check {
        background-color: var(--ready);
        border-color: var(--ready);
    }

    /* Action Buttons */
    .action-button {
        background-color: var(--ready);
        color: white;
        border: none;
        border-radius: 4px;
        padding: 8px 12px;
        font-weight: bold;
        cursor: pointer;
        transition: background-color 0.2s;
        margin-top: 10px;
        width: 100%;
        box-sizing: border-box;
    }
    .action-button:hover { background-color: #15803d; }
    
    /* Recall Button (used in completed status bubble metas) */
    .btn-recall {
        background-color: var(--new);
        color: white;
        border: none;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.8em;
        cursor: pointer;
    }
    .btn-recall:hover { background-color: #2563eb; }

    /* Dragging styles */
    .dragging {
        opacity: 0.5;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
    }
    .drag-over {
        border-color: var(--accent);
        background-color: var(--drag-hover-color);
    }

    /* Header/Filter Tabs */
    #header-container {
        background-color: #fff;
        padding: 10px 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    #filter-tabs button {
        background-color: #f3f4f6;
        color: var(--text);
        border: none;
        padding: 8px 15px;
        margin: 0 5px;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 600;
        transition: background-color 0.2s;
    }
    #filter-tabs button.active {
        background-color: var(--accent);
        color: white;
    }
    
    /* Status indicators for completed/cancelled */
    .bubble.cancelled { 
        background-color: #fef2f2; /* Very light red background */
        border-color: var(--cancel);
        opacity: 0.7;
    }
    .bubble.ready { 
        background-color: #f0fff4; /* Very light green background */
        border-color: var(--ready);
        opacity: 0.85;
    }

    /* --- NEW/UPDATED STYLES for persistence and new fields --- */
    .bubble-note {
        background-color: #f7f7f7; 
        color: var(--text);
        padding: 0.5rem 1rem;
        border-radius: 6px;
        font-size: 0.95rem;
        font-style: italic;
        margin-bottom: 10px;
        border-left: 3px solid var(--accent);
        white-space: pre-wrap;
    }
    .fulfillment-type-tag {
        font-size: 0.85rem;
        font-weight: 800;
        padding: 0.25rem 0.6rem;
        border-radius: 4px;
        background-color: var(--new); 
        color: white;
        margin-bottom: 0.5rem;
        align-self: flex-end;
    }
    .bubble-metas {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 5px;
    }
    .bubble-footer {
        padding: 0 15px 15px;
    }

  </style>
</head>
<body>
  
  <div id="header-container">
    <h1>VertiDog KDS</h1>
    <div id="filter-tabs">
        <button id="tab-active" data-filter="active" class="active">Active</button>
        <button id="tab-in-progress" data-filter="in-progress">In Progress</button>
        <button id="tab-ready" data-filter="ready">Completed</button>
        <button id="tab-cancelled" data-filter="cancelled">Cancelled</button>
        <button onclick="sendTestOrder()">Test Order</button>
    </div>
  </div>

  <div id="kds-grid">
    </div>

  <script>
    const WS_URL = `ws://${window.location.host}`;
    let socket;
    const orders = {}; 
    let currentFilter = 'active'; 

    // Utility to prevent XSS and safely display order numbers/text
    function escapeHtml(text) {
        return text ? String(text).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;") : '';
    }

    // Timer formatting
    function formatTimeElapsed(createdAt) {
        const seconds = Math.floor((Date.now() - createdAt) / 1000);
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
    }

    // Update the timer on the bubble's top bar color
    function updateTimers() {
        document.querySelectorAll('.bubble').forEach(bubble => {
            const orderNumber = bubble.dataset.orderNumber;
            const order = orders[orderNumber];
            if (order && order.status !== 'ready' && order.status !== 'cancelled') {
                const elapsed = Date.now() - order.createdAt;
                const topBar = bubble.querySelector('.bubble-top-bar > div:last-child');
                if (topBar) {
                    // Set color based on time (e.g., 3 mins = Alert, 5 mins = Critical)
                    if (elapsed > 300000) { // 5 minutes
                        topBar.style.color = 'var(--time-critical)';
                    } else if (elapsed > 180000) { // 3 minutes
                        topBar.style.color = 'var(--time-alert)';
                    } else {
                        topBar.style.color = 'white';
                    }
                    topBar.textContent = formatTimeElapsed(order.createdAt);
                }
            }
        });
    }
    
    // Start timer interval (updates every second)
    setInterval(updateTimers, 1000);


    // Add/Update order in local memory and re-render
    function addOrUpdate(orderNumber, status, orderData) {
        // If updating an existing order, merge data
        if (orders[orderNumber]) {
            orders[orderNumber] = { ...orders[orderNumber], ...orderData, status: status };
        } else {
            // For a brand new order
            orders[orderNumber] = { ...orderData, status: status };
        }
        render();
    }

    // --- ITEM HTML RENDERING (with Completion Checkbox) ---
    function renderItemsHtml(orderNumber, items, maxRows) {
        return items.map((item, index) => {
            const completedClass = item.completed ? 'completed' : '';
            const checkMark = item.completed ? '&#10003;' : '';
            const modifierHtml = item.modifiers && item.modifiers.length 
                ? `<div class="modifiers">${item.modifiers.join(', ')}</div>` 
                : '';
            
            return `
                <div class="item ${completedClass}" 
                     data-item-index="${index}" 
                     onclick="toggleItemCompletion('${orderNumber}', ${index}, ${!item.completed})">
                    <div class="item-left">
                        <span class="item-check">${checkMark}</span>
                        <span class="item-name">${escapeHtml(item.name)}</span>
                    </div>
                    <span class="item-quantity">${item.quantity}x</span>
                </div>
                ${modifierHtml}
            `;
        }).join('');
    }

    // --- MAIN RENDER FUNCTION ---
    function render() {
      const bubbleContainer = document.getElementById('kds-grid');
      bubbleContainer.innerHTML = ''; // Clear current grid

      // 1. Filter orders based on the current active tab
      let filteredList = Object.values(orders).filter(o => {
        if (currentFilter === 'active') {
          return o.status === 'new' || o.status === 'in-progress';
        }
        return o.status === currentFilter;
      });
      
      // Sort orders: In Progress first, then by oldest (createdAt)
      filteredList.sort((a, b) => {
          if (a.status === 'in-progress' && b.status !== 'in-progress') return -1;
          if (a.status !== 'in-progress' && b.status === 'in-progress') return 1;
          return a.createdAt - b.createdAt;
      });

      // 2. Render each filtered order
      filteredList.forEach((o) => {
        const b = document.createElement('div');
        b.className = `bubble ${o.status}`;
        b.dataset.orderNumber = o.orderNumber;
        b.draggable = true;
        
        // Status text logic
        let statusText = o.status.toUpperCase().replace('-', ' ');
        if (o.status === 'ready' || o.status === 'cancelled') {
            statusText = o.status === 'ready' ? 'COMPLETED' : 'CANCELLED';
        }
        
        const priorityIcon = o.priority ? 'ðŸ”¥' : '';
        const priorityBtn = o.status !== 'ready' && o.status !== 'cancelled' 
            ? `<button onclick="togglePriority('${o.orderNumber}', ${!o.priority})" class="btn-priority">P</button>` 
            : '';

        // Timer is only shown for active/in-progress orders
        const timerHtml = (o.status === 'new' || o.status === 'in-progress') 
            ? `<span class="bubble-timer">${formatTimeElapsed(o.createdAt)}</span>` 
            : '';
        
        const itemCountText = `${o.itemCount} Item${o.itemCount === 1 ? '' : 's'}`;
        
        // Recall button for completed/cancelled section
        const recallButtonHtml = (o.status === 'ready' || o.status === 'cancelled') 
            ? `<button onclick="recallOrder('${o.orderNumber}')" class="btn-recall">RECALL</button>`
            : '';

        const itemsHtml = renderItemsHtml(o.orderNumber, o.items, 99);
        
        // --- NEW VARIABLES (for fulfillment type and note) ---
        const fulfillmentType = escapeHtml(o.fulfillmentType || 'Dine In');
        const orderNote = escapeHtml(o.orderNote || '');
        const noteHtml = (orderNote && (o.status === 'new' || o.status === 'in-progress')) 
            ? `<div class="bubble-note">${orderNote}</div>` 
            : '';

        b.innerHTML = `
          <div class="bubble-top-bar ${o.status !== 'ready' ? o.status : ''}">
              <div>${statusText} ${priorityIcon} ${priorityBtn}</div>
              <div>${timerHtml}</div>
          </div>

          <div class="bubble-body">
              <div class="bubble-header">
                <div>
                  <div class="bubble-number">${escapeHtml(o.orderNumber)}</div>
                  <div class="bubble-meta">${escapeHtml(itemCountText)}</div>
                </div>
                <div class="bubble-metas">
                  <div class="fulfillment-type-tag">${fulfillmentType}</div>
                  ${recallButtonHtml}
                </div>
              </div>

              ${noteHtml} <div class="bubble-items">
                ${itemsHtml}
              </div>
          </div>
          
          <div class="bubble-footer">
              ${o.status !== 'ready' && o.status !== 'cancelled' ? `<button class="action-button" onclick="markReady('${o.orderNumber}')">COMPLETE ORDER</button>` : ''}
          </div>
        `;

        bubbleContainer.appendChild(b);
        // Apply overflow-y rule based on content size for the newly created bubble
        const itemsContainer = b.querySelector('.bubble-items');
        if (itemsContainer) {
            itemsContainer.style.overflowY = itemsContainer.scrollHeight > itemsContainer.clientHeight ? 'auto' : 'unset';
        }
      });
    }
    
    // --- WEBSOCKET CONNECTION & HANDLER ---

    function connect() {
      if (socket && socket.readyState === 1) return;

      socket = new WebSocket(WS_URL);

      socket.onopen = () => {
        console.log("WebSocket connected.");
        // Request current state on connect (this triggers SYNC_STATE)
        socket.send(JSON.stringify({ type: "SYNC_REQUEST" }));
      };

      // Handler for incoming messages from server
      socket.onmessage = (event) => {
        const msg = JSON.parse(event.data);
        console.log("Message received:", msg.type);

        switch (msg.type) {
            
            // --- FIX FOR PERSISTENCE (Receives ALL orders on refresh) ---
            case 'SYNC_STATE':
                // Clear local memory before full sync
                Object.keys(orders).forEach(key => delete orders[key]);
                
                msg.orders.forEach(order => {
                    // Add all orders (active, ready, cancelled) to local memory
                    orders[order.orderNumber] = order; 
                });
                render(); // Render all orders based on the current filter
                break;
            // -----------------------------------------------------------

            case 'NEW_ORDER':
                // This handles all status updates (new, in-progress, ready, cancelled)
                addOrUpdate(msg.orderNumber, msg.status, msg);
                break;

            case 'ITEM_COMPLETED_CONFIRM':
                // Find the order and update the specific item status
                if(orders[msg.orderNumber] && orders[msg.orderNumber].items[msg.itemIndex]) {
                    orders[msg.orderNumber].items[msg.itemIndex].completed = msg.completed;
                }
                // --- CRITICAL FIX: If the server sends a full order object, it means the status changed (new -> in-progress) ---
                if (msg.order) {
                    // Force the full order object merge and trigger a full redraw
                    addOrUpdate(msg.orderNumber, msg.order.status, msg.order); 
                }
                // If all items are complete, mark the whole order ready
                if(msg.allCompleted) {
                    markReady(msg.orderNumber, { playSound: false }); 
                }
                render(); // Rerender to update item checked state
                break;

            default:
                console.log("Unknown message type:", msg.type);
        }
      };

      socket.onclose = () => {
        console.log("WebSocket disconnected. Attempting reconnect in 3s...");
        setTimeout(connect, 3000); 
      };

      socket.onerror = (err) => {
        console.error("WebSocket error:", err);
        socket.close();
      };
    }

    // --- USER ACTIONS ---

    function toggleItemCompletion(orderNumber, itemIndex, completed) {
        if (socket.readyState === 1) {
            socket.send(JSON.stringify({ 
                type: "ITEM_COMPLETED", 
                orderNumber, 
                itemIndex, 
                completed 
            }));
        }
    }
    
    function markReady(orderNumber, options = { playSound: true }) {
        if (socket.readyState === 1) {
            socket.send(JSON.stringify({ type: "ORDER_READY", orderNumber }));
        }
    }

    function recallOrder(orderNumber) {
        if (socket.readyState === 1) {
            socket.send(JSON.stringify({ type: "ORDER_REACTIVATED", orderNumber }));
        }
    }
    
    function togglePriority(orderNumber, priority) {
        // Placeholder for priority logic
        console.log(`Toggling priority for ${orderNumber} to ${priority}`);
    }

    function sendTestOrder() {
        fetch('/test-order')
            .then(response => response.text())
            .then(text => console.log('Test order sent:', text))
            .catch(error => console.error('Error sending test order:', error));
    }

    // --- FILTER TABS LOGIC ---
    document.getElementById('filter-tabs').addEventListener('click', (event) => {
        const target = event.target;
        if (target.tagName === 'BUTTON' && target.dataset.filter) {
            currentFilter = target.dataset.filter;
            
            // Update active class
            document.querySelectorAll('#filter-tabs button').forEach(btn => {
                btn.classList.remove('active');
            });
            target.classList.add('active');

            render(); // Re-render the grid with the new filter
        }
    });


    // Start the connection when the page loads
    document.addEventListener('DOMContentLoaded', connect);

    // Initial render when the page loads
    render();
  </script>
</body>
</html>
